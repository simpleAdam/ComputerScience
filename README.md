# ComputerScience
### repository for CS topics

* FizzBuzz
  FizzBuzz is a very simple programming task, used in software developer job interviews, to determine whether the job candidate can actually write code. It was ['invented' in 2007 by Imran Ghory](http://imranontech.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/), and [popularized by Jeff Atwood](http://blog.codinghorror.com/why-cant-programmers-program/). Here is a description of the task:

    Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”.

It’s very well known in software development circles. There are multiple implementations in every language, joke implementations, and plenty of articles discussing its usefulness during the hiring process.

* Tokenizers, Lexers and Parsers.

 (A Stack Overflow answer). 
  A tokenizer breaks a stream of text into tokens, usually by looking for whitespace (tabs, spaces, new lines).
  
  A lexer is basically a tokenizer, but it usually attaches extra context to the tokens -- this token is a number, that token is a string literal, this other token is an equality operator.
  
  A parser takes the stream of tokens from the lexer and turns it into an abstract syntax tree representing the (usually) program represented by the original text.
  
  The best book on the subject was "Compilers: Principles, Techniques, and Tools" usually just known as "The Dragon Book". Compilers: Principles, Techniques, and Tools, first published 1986, is known as the Dragon Book to generations of computer scientists as its cover depicts a knight and a dragon in battle, a metaphor for conquering complexity. 

* Programming Topics
  * > Generators and Coroutines
  * > Modular programming
    - Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules. 
    - The term assembly (as in .NET languages like C#, F# or Visual Basic .NET) or package (as in Dart, Go or Java) is sometimes used instead of module.

* Google web Fundamentals
 According to Google, the core foundations of a 'delightful web experience' are;
  * > Fast - It responds quickly to user interactions with silky smooth animations and no janky scrolling.
  * > Integrated - The user doesn’t have to reach through the browser, it uses the full capabilities of the device to create an experience true to the device.
  * > Reliable - Load instantly and reliably, never showing the downasaur, even in uncertain network conditions.
  * > Engaging - Keeps the user coming back to the app with beautifully designed experiences that look and feel natural.

* Responsive Web Design principles
  * > The fluid grid concept calls for page element sizing to be in relative units like percentages, rather than absolute   units like pixels or points
  * > Flexible images are also sized in relative units, so as to prevent them from displaying outside their containing element.
  * > Media queries allow the page to use different CSS style rules based on characteristics of the device the site is being displayed on.
  
* #### Theory of Computation
  The theory of computation can be considered the creation of models of all kinds in the field of computer science.
  
  Language theory is a branch of mathematics concerned with describing languages as a set of operations over an alphabet. It is closely linked with automata theory, as automata are used to generate and recognize formal languages. 
  
    Automata theory is the study of abstract machines
    * Type-0,	Recursively enumerable,	Turing machine
    * Type-1,	Context-sensitive,	Linear-bounded non-deterministic Turing machine

* MVC
  * I spent a very happy and inspiring year as a visiting scientist with the Learning Research Gorup (LRG) at Xerox PARC from the summer og 1978 to the summer of 1979. This group was dedicated to Alan Kay's vision of the Dynabook; a portable computer that should contain all data of interest to its owner/user. Very importantly, these data included the programs the owner used to manipulate them. The owner/user should be able to understand and write the programs, thus gaining ascendancy over the computer.
  * I have sometimes been given more credit than is my due, so I should stress that I am not one of the original inventors of Smalltalk. I am only one of the very early and very enthusiastic users and contributors to this revolutionary innovation. I made the first implementation and wrote the original MVC note at Xerox PARC in 1978. The note defines four terms; Model, View, Controller and Editor . The Editor is an ephemeral component that the View creates on demand as an interface between the View and the input devices such as mouse and keyboard.
  * Jim Althoff and others implemented a version of MVC for the Smalltalk-80 class library after I had left Xerox PARC; I was in not involved in this work. Jim Althoff uses the term Controller somewhat differently from me. An important aspect of the original MVC was that its Controller was responsible for creating and coordinating its subordinate views. Also, in my later MVC implementations, a view accepts and handles user input relevant to itself. The Controller accepts and handles input relevant to the Controller/View assembly as a whole, now called the Tool.
  * The essential purpose of MVC is to bridge the gap between the human user's mental model and the digital model that exists in the computer. The ideal MVC solution supports the user illusion of seeing and manipulating the domain information directly. The structure is useful if the user needs to see the same model element simultaneously in different contexts and/or from different viewpoints. The figure below illustrates the idea.
  ...
  [Trygve Reenskaug](http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html)

* Databases
  * Conceptual modeling The Entity-Relationship
  * The relational model
  * The graph-oriented model The NoSQL movement. Implementing ER models in a graph-oriented database.
  * The document-oriented model Semi-structured data (XML, JSON).
  * The multi-dimensional model.
  
* Digital Electronics

* Checksum
  * A checksum is a small-sized datum derived from a block of digital data for the purpose of detecting errors that may have been introduced during its transmission or storage. By themselves, checksums are often used to verify data integrity but are not relied upon to verify data authenticity. 

* Discrete Mathematic - Time in computer games is not continuous - it is split up into frames of 1/60th of a second.

* Foundations of Computer Science
* Computer Graphics
   * > Vectors, Points and Coordiante Systems
   * > Affine Combinations and Affine Space
   * > Matrices
   * > Polygons Vs Curves
   * > Chakins curves, Bezier curves, Subdivision Surfaces
   * ``` ```
   * > Transformations: translation, rotation, scaling
   * > Cameras: camera transform, perspective, field of view
   * > 
   
* Machine Learning
 * > Mathematical optimizaton problem
 * > Dynamic programming, Memoization, Bellman
* Object-Oriented Programming
  * > Polymorphism, static or dynamic
* Registration
* Scientific Computing
* Algorithms and Data Structures 
    * Arrays
    * Linked Lists
    * Stack
    * Queue
    * Hash table
    * Trees
    * Graphs
* Operating Systems
* Interaction Design
* Numerical Analysis
* Software and Security Engineering
 
* Computer Design
* Concurrent and Distributed Systems
* ECAD and Architecture
* Foundations of Data Science
* Programming in C and C++
* Programming in Java
* Semantics of Programming Languages
* Unix Tools
* Compiler Construction
* Computation Theory
* Computer Networking
* Human–Computer Interaction
* Logic and Proof
* Artificial Intelligence
* Complexity Theory
* Concepts in Programming Languages
* Formal Models of Language

* Bioinformatics
* Denotational Semantics
* Information Theory
* LaTeX and MATLAB
* Principles of Communications
* Quantum Computing
* Types
* Cloud Computing
* Metaprogramming
* Multicore Semantics and Programming
* Natural Language Processing
* Comparative Architectures
* Computer Vision
* Cryptography
* E-Commerce
* Mobile and Sensor Systems
* Optimising Compilers
* Digital Signal Processing
* Mobile Robot Systems
* Probability and Computation
* Concurrency
* Hoare Logic and Model Checking 
* Machine Learning and Bayesian Inference

------------------
Distributed computing is a field of computer science that studies distributed systems. 
A distributed system is a system whose components are located on different networked computers, 
which communicate and coordinate their actions by passing messages to one another.

## Control Structures
### Flow of Control:
Flow of control through any given function is implemented with three basic types of control structures:
Sequential: default mode. Sequential execution of code statements (one line after another) -- like following a recipe
#### Selection: used for decisions, branching -- choosing between 2 or more alternative paths. In C++, these are the types of # selection statements:
* if
* if/else
* switch
#### Repetition: used for looping, i.e. repeating a piece of code multiple times in a row. In C++, there are three types of loops:
* while
* do/while
* for

The function construct, itself, forms another way to affect flow of control through a whole program. 

## virtual machines
### Stack Machines
In computer science, computer engineering and programming language implementations, a stack machine is a type of computer. In some cases, the term refers to a software scheme that simulates a stack machine.

The main difference from other computers is that most of its instructions operate on a pushdown stack of numbers rather than numbers held in processor registers. Because the operands used in the instructions are always in a known location, the top of the stack, the instructions themselves do not require memory addresses or register numbers to supply their operands. This leads to an instruction set architecture (ISA) style known as a zero address format.

Stacks are not unique to stack machines, most programming languages make extensive use of stacks to support subroutines and method calls. For this reason, stack machines more closely mimic the inner workings of the programs that run on them, assuming the programs are written in high level languages. This has led to a number of central processor unit designs that implement stack machines in order to provide higher performance. In practice, however, these designs have been outperformed by the traditional register machine systems, and have remained a niche player in the market.

--------------
## context-free grammar
The ECMAScript spec defines four grammars:

The lexical grammar describes how Unicode code points are translated into a sequence of input elements (tokens, line terminators, comments, white space).

The syntactic grammar defines how syntactically correct programs are composed of tokens.

The RegExp grammar describes how Unicode code points are translated into regular expressions.

The numeric string grammar describes how Strings are translated into numeric values.

Each grammar is defined as a context-free grammar, consisting of a set of productions.

The grammars use slightly different notation: the syntactic grammar uses LeftHandSideSymbol : whereas the lexical grammar and the RegExp grammar use LeftHandSideSymbol :: and the numeric string grammar uses LeftHandSideSymbol :::.

-------------
## dynamic programming
Memoization is at the heart of dynamic programming

-------------
## Object Orient Programming
Single-responsibility principle
 >   A class should only have a single responsibility, that is, only changes to one part of the software's specification should be able to affect the specification of the class.
 
Open–closed principle
 >   "Software entities ... should be open for extension, but closed for modification."
 
Liskov substitution principle
 >   "Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program." See also design by contract.

Interface segregation principle
  >  "Many client-specific interfaces are better than one general-purpose interface."

Dependency inversion principle[10]
 >   One should "depend upon abstractions, [not] concretions."

--------------
## webpack
It's a funny story how I started with webpack. Before getting addicted to JavaScript, I also developed in Java. I tried GWT (Google Web Toolkit) in that time. GWT is a Java-to-JavaScript Compiler, which has a great feature: code splitting. I liked this feature and missed it in existing JavaScript tooling. I opened an issue to an existing module bundler, but it did not go forward. Webpack was born.

Somehow the Instagram frontend team discovered an early version of webpack and started to use it for instagram.com. Pete Hunt, Facebook employee managing the Instagram web team, gave the first significant talk about webpack at OSCON 2014. The talk boosted the popularity of webpack. One of the reasons for adoption of webpack by Instagram was code splitting.

I have been following this book since its early stages. It was once a combined React and webpack book. It has grown since then and become a book of its own filled with content.

Juho is an important part of the webpack documentation team for the webpack documentation, so he knows best what complements the official documentation. He has used this knowledge to create a book that supplies you with a deep understanding of webpack and teaches you to use the tool to its full potential.

 > Tobias Koppers
